/**
 * Python Bridge Utility
 * 
 * This module provides utility functions to communicate with Python scripts
 * from Node.js applications. It handles spawning Python processes,
 * serializing/deserializing data, and error handling.
 */

const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs').promises;
const logger = require('./logger');

// Path to the Python wrapper script
const PYTHON_WRAPPER_SCRIPT = path.resolve(process.cwd(), '../py_models/enhancer_wrapper.py');

// Path to Python virtual environment
const PYTHON_VENV_PATH = path.resolve(process.cwd(), '../py_env/bin/python');

// Default timeout for Python processes (in milliseconds)
const DEFAULT_TIMEOUT = 60000; // 60 seconds

/**
 * Execute a Python function with the provided arguments
 * 
 * @param {string} functionName - Name of the function to call
 * @param {Object} data - Data to pass to the Python function
 * @param {number} timeout - Timeout in milliseconds (default: 60000)
 * @returns {Promise<Object>} - Promise resolving with the Python function result
 */
const executePythonFunction = async (functionName, data, timeout = DEFAULT_TIMEOUT) => {
  return new Promise(async (resolve, reject) => {
    let timeoutId;
    let isResolved = false;

    try {
      // Check if wrapper script exists
      await fs.access(PYTHON_WRAPPER_SCRIPT)
        .catch((error) => {
          logger.error(`Python wrapper script not found: ${PYTHON_WRAPPER_SCRIPT}`, { error });
          throw new Error(`Python wrapper script not found: ${PYTHON_WRAPPER_SCRIPT}`);
        });
      
      // Prepare input data for Python script
      const jsonData = JSON.stringify(data);
      
      // Determine Python executable (use virtual environment if available)
      let pythonExecutable;
      try {
        await fs.access(PYTHON_VENV_PATH);
        logger.info(`Using Python virtual environment: ${PYTHON_VENV_PATH}`);
        pythonExecutable = PYTHON_VENV_PATH;
      } catch (error) {
        logger.warn(`Python virtual environment not found at ${PYTHON_VENV_PATH}, falling back to system Python`);
        pythonExecutable = 'python3';
      }
      
      // Log the command for debugging
      logger.info(`Executing Python command: ${pythonExecutable} ${PYTHON_WRAPPER_SCRIPT} --function ${functionName}`);
      
      // Spawn Python process
      const pythonProcess = spawn(pythonExecutable, [
        PYTHON_WRAPPER_SCRIPT,
        '--function', functionName,
        '--data', jsonData
      ]);
      
      let result = '';
      let errorOutput = '';
      
      // Set timeout
      timeoutId = setTimeout(() => {
        if (!isResolved) {
          isResolved = true;
          logger.error(`Python process timed out after ${timeout}ms`, { function: functionName });
          
          // Kill the process
          try {
            pythonProcess.kill('SIGTERM');
          } catch (error) {
            logger.error('Failed to kill Python process', { error });
          }
          
          reject(new Error(`Python process timed out after ${timeout}ms`));
        }
      }, timeout);
      
      // Collect data from stdout
      pythonProcess.stdout.on('data', (data) => {
        result += data.toString();
      });
      
      // Collect data from stderr
      pythonProcess.stderr.on('data', (data) => {
        errorOutput += data.toString();
        logger.error(`Python stderr: ${data.toString()}`);
      });
      
      // Handle process completion
      pythonProcess.on('close', (code) => {
        clearTimeout(timeoutId);
        
        if (isResolved) return;
        isResolved = true;
        
        if (code !== 0) {
          logger.error(`Python process exited with code ${code}`, { error: errorOutput });
          reject(new Error(`Python process failed with error: ${errorOutput || 'Unknown error'}`));
          return;
        }
        
        try {
          // Try to parse the result as JSON
          logger.info(`Python output: ${result.substring(0, 200)}${result.length > 200 ? '...' : ''}`);
          const parsedResult = JSON.parse(result);
          
          // Check if the result contains an error
          if (parsedResult.error) {
            logger.error('Python function returned an error', { 
              error: parsedResult.error,
              traceback: parsedResult.traceback
            });
            reject(new Error(parsedResult.error));
            return;
          }
          
          resolve(parsedResult);
        } catch (error) {
          logger.error('Failed to parse Python output as JSON', { error, output: result });
          // If it's not JSON, just return the raw output
          resolve({ rawOutput: result });
        }
      });
      
      // Handle process errors
      pythonProcess.on('error', (error) => {
        clearTimeout(timeoutId);
        
        if (isResolved) return;
        isResolved = true;
        
        logger.error('Failed to start Python process', { error });
        reject(new Error(`Failed to start Python process: ${error.message}`));
      });
    } catch (error) {
      clearTimeout(timeoutId);
      
      if (isResolved) return;
      isResolved = true;
      
      logger.error('Error in executePythonFunction', { error });
      reject(error);
    }
  });
};

/**
 * Enhance a resume using the Python enhancement function
 * 
 * @param {Object} resumeData - Resume data from Gemini classification
 * @returns {Promise<Object>} - Promise resolving with the enhanced resume data
 */
const enhanceResume = async (resumeData) => {
  try {
    // Validate input data
    if (!resumeData || !resumeData.data || !resumeData.data.classification) {
      throw new Error('Invalid resume data format');
    }
    
    // Implement retry logic
    const maxRetries = 2;
    let retries = 0;
    let lastError;
    
    while (retries <= maxRetries) {
      try {
        // Call Python function to enhance resume
        const result = await executePythonFunction('parse_enhanced_resume', resumeData);
        logger.info(`Successfully enhanced resume after ${retries} retries`);
        return result;
      } catch (error) {
        lastError = error;
        retries++;
        
        if (retries <= maxRetries) {
          logger.warn(`Retrying parse_enhanced_resume (attempt ${retries}/${maxRetries})`, { error });
          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }
    
    // If we've reached this point, all retries failed
    logger.error('Resume enhancement failed after all retries', { error: lastError });
    throw new Error(`Resume enhancement failed after ${maxRetries} retries: ${lastError.message}`);
  } catch (error) {
    logger.error('Resume enhancement failed', { error });
    throw new Error(`Resume enhancement failed: ${error.message}`);
  }
};

/**
 * Generate LaTeX from resume data
 * 
 * @param {Object} resumeData - Resume data from classification
 * @returns {Promise<string>} - Promise resolving with the LaTeX code
 */
const generateLatex = async (resumeData) => {
  try {
    // Call Python function to generate LaTeX
    const result = await executePythonFunction('render_latex', resumeData);
    
    return result.text || result.rawOutput;
  } catch (error) {
    logger.error('LaTeX generation failed', { error });
    throw new Error(`LaTeX generation failed: ${error.message}`);
  }
};

/**
 * Match jobs based on resume data
 * 
 * @param {Object} resumeData - Resume data from classification
 * @returns {Promise<Object>} - Promise resolving with matched jobs
 */
const matchJobs = async (resumeData) => {
  try {
    // Call Python function to match jobs
    const result = await executePythonFunction('match_jobs', resumeData);
    
    return result;
  } catch (error) {
    logger.error('Job matching failed', { error });
    throw new Error(`Job matching failed: ${error.message}`);
  }
};

/**
 * Generate a learning path based on resume data
 * 
 * @param {Object} resumeData - Resume data from classification
 * @returns {Promise<string>} - Promise resolving with the learning path
 */
const generateLearningPath = async (resumeData) => {
  try {
    // Call Python function to generate learning path
    const result = await executePythonFunction('generate_learning_path', resumeData);
    
    return result.text || result.rawOutput;
  } catch (error) {
    logger.error('Learning path generation failed', { error });
    throw new Error(`Learning path generation failed: ${error.message}`);
  }
};

/**
 * Generate a cover letter based on resume data and job description
 * 
 * @param {Object} resumeData - Resume data from classification
 * @param {string} selectedJobTitle - Title of the selected job
 * @param {string} selectedJobDescription - Description of the selected job
 * @param {string} companyName - Name of the company
 * @returns {Promise<string>} - Promise resolving with the cover letter
 */
const generateCoverLetter,
  resolveTemplatePath,
  verifyTemplates,
  getPerformanceMetrics = async (resumeData, selectedJobTitle, selectedJobDescription, companyName) => {
  try {
    // Call Python function to generate cover letter
    const result = await executePythonFunction('generate_cover_letter', {
      resumeData,
      selectedJobTitle,
      selectedJobDescription,
      companyName
    });
    
    return result.text || result.rawOutput;
  } catch (error) {
    logger.error('Cover letter generation failed', { error });
    throw new Error(`Cover letter generation failed: ${error.message}`);
  }
};

module.exports = {
  executePythonFunction,
  enhanceResume,
  generateLatex,
  matchJobs,
  generateLearningPath,
  generateCoverLetter,
  resolveTemplatePath,
  verifyTemplates,
  getPerformanceMetrics
}; 